<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>负载均衡与反向代理</title>
      <link href="/2023/09/09/loadbalance/"/>
      <url>/2023/09/09/loadbalance/</url>
      
        <content type="html"><![CDATA[<h1 id="系统设计系列初衷"><a href="#系统设计系列初衷" class="headerlink" title="系统设计系列初衷"></a>系统设计系列初衷</h1><p>System Design Primer： 英文文档 <a href="https://so.csdn.net/so/search?q=GitHub&amp;spm=1001.2101.3001.7020">GitHub</a> - donnemartin/system-design-primer: Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.</p><p><a href="https://so.csdn.net/so/search?q=%E4%B8%AD%E6%96%87%E7%89%88&amp;spm=1001.2101.3001.7020">中文版</a>： <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md">https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md</a></p><p>初衷主要还是为了学习系统设计，但是这个中文版看起来就像<a href="https://so.csdn.net/so/search?q=%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91&amp;spm=1001.2101.3001.7020">机器翻译</a>的一样，所以还是手动做一些简单的笔记，并且在难以理解的地方对照英文版，根据自己的理解在AI的帮助下进行翻译和知识扩展。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p><img src="https://img-blog.csdnimg.cn/8ae191445c534fef94aaaa2726518c2e.png" alt=""></p><p>资料来源：可缩放系统构架介绍</p><p>首先需要了解下服务层和应用层的概念：</p><h2 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h2><p>主要负责处理系统的业务逻辑。服务层为应用层提供功能性的支持，包括数据验证、数据处理、业务流程控制等。服务层通过将底层数据处理和逻辑封装起来，为应用层提供了更高层次的抽象，使应用层可以更方便地使用这些服务。</p><h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><p>是软件系统的最高层次，直接为用户提供功能和服务。应用层包括各种应用程序、客户端和服务器等。应用层通过调用服务层提供的功能，实现了对用户需求的响应和满足。应用层需要关注用户交互、用户体验以及各种应用程序的实现。</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>服务层和应用层的关系主要体现在以下几个方面：</p><p>服务层为应用层提供服务：服务层通过封装底层数据处理和逻辑，为应用层提供了更高层次的抽象。应用层通过调用服务层提供的功能，实现了对用户需求的响应和满足。</p><p>应用层依赖服务层：应用层需要实现各种功能和服务，而这些功能和服务很大程度上依赖于服务层提供的支持。服务层设计的好坏直接影响应用层的性能、稳定性和可维护性。</p><p>服务层和应用层相互隔离：服务层和应用层在功能上相互独立，它们之间的接口清晰明确。这样，当需求发生变化时，可以灵活地进行调整和修改。服务层和应用层相互隔离的设计有助于提高系统的可维护性和可扩展性。</p><p>早期的服务层基于应用层存在，共同部署在同一个平台，共同运维。</p><p>而微服务的提出将 Web 服务层与应用层（也被称作平台层）分离，可以独立缩放和配置这两层。添加新的 API 只需要添加应用服务器，而不必添加额外的 web 服务器。</p><p>单一职责原则提倡小型的，自治的服务共同合作。小团队通过提供小型的服务，可以更激进地计划增长。</p><p>应用层中的工作进程也有可以实现<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%BC%82%E6%AD%A5" title="异步化">异步化</a>。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p><a href="https://en.wikipedia.org/wiki/Microservices" title="微服务">微服务</a>，可以被描述为一系列可以独立部署的小型的，模块化服务。每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标。</p><p>例如，Pinterest 可能有这些微服务： 用户资料、关注者、Feed 流、搜索、照片上传等。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>微服务的主要优势包括：</p><p>灵活性：微服务可以独立进行开发、测试和部署，从而加快软件开发的迭代速度。同时，每个服务都可以根据实际需求选择合适的技术栈，使得开发者能够更加灵活地应对不同的业务场景。</p><p>可扩展性：通过将复杂的应用程序拆分成多个简单的微服务，系统可以在需要时更容易地进行水平扩展。这使得系统能够根据业务需求的变化快速调整资源，提高系统的整体性能。</p><p>高可用性：由于每个微服务都是独立的，因此一个服务的故障不会直接导致整个系统崩溃。此外，微服务架构通常采用去中心化的设计，进一步提高了系统的容错能力。</p><p>松耦合：微服务之间的通信采用轻量级的 HTTP API，使得服务之间的依赖关系更加松散。这有助于降低系统间的耦合度，使得系统在面对需求变更时更加灵活。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>系统设计系列初衷</p><p>System Design Primer： 英文文档 <a href="https://so.csdn.net/so/search?q=GitHub&amp;spm=1001.2101.3001.7020">GitHub</a> - donnemartin/system-design-primer: Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.</p><p><a href="https://so.csdn.net/so/search?q=%E4%B8%AD%E6%96%87%E7%89%88&amp;spm=1001.2101.3001.7020">中文版</a>： <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md">https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md</a></p><p>初衷主要还是为了学习系统设计，但是这个中文版看起来就像<a href="https://so.csdn.net/so/search?q=%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91&amp;spm=1001.2101.3001.7020">机器翻译</a>的一样，所以还是手动做一些简单的笔记，并且在难以理解的地方对照英文版，根据自己的理解在AI的帮助下进行翻译和知识扩展。  </p><h1 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h1><p><img src="https://img-blog.csdnimg.cn/c1749ae334584118a69ddab796c47375.png" alt=""></p><p>来源：可扩展的系统设计模式 </p><p>说到负载均衡器，首先就是要引入负载均衡的概念</p><h2 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h2><p>负载均衡（Load Balance）是一种网络优化技术，用于在高并发访问和高负载情况下，分摊网络设备和服务器的工作压力，提高系统的处理能力、吞吐量和可用性。通过将请求流量自动分配给多个操作单元（例如 Web 服务器、FTP 服务器、企业关键应用服务器等），共同完成任务，从而避免单一服务器设备过载，降低系统故障的风险。</p><p>负载均衡技术可以有效提高网络设备的利用率，降低硬件投资成本，同时确保用户享受到较高的服务质量和响应速度。在实际应用中，负载均衡通常用于以下场景：</p><p>高并发访问：当网站、应用或服务面临大量用户同时访问时，负载均衡可以将请求分发至多个服务器，确保每个服务器的负载适中，避免其中某台服务器过载。</p><p>高负载处理：对于计算密集型任务或数据处理任务，负载均衡可以将任务分配给多台服务器，提高整体处理速度，缩短任务完成时间。</p><p>服务器故障恢复：当某台服务器出现故障时，负载均衡可以自动将其从服务队列中移除，并将请求分发至其他正常运行的服务器，确保服务的连续性和稳定性。</p><h2 id="什么是负载均衡器"><a href="#什么是负载均衡器" class="headerlink" title="什么是负载均衡器"></a>什么是负载均衡器</h2><p>负载均衡器（Load Balancer）是一种网络优化设备，用于在多个服务器或网络链接之间分配负载，提高系统的可靠性、可用性和性能。负载均衡器可以有效地解决服务器或网络链路过载问题，保证用户请求能够及时得到响应，从而提高用户体验。</p><p>负载均衡器可以根据不同的策略对流量进行分配，例如轮询（Round Robin）、最少连接（Least Connections）和源 IP 哈希（Source IP Hash）等。此外，负载均衡器还具有其他功能，如应用交换、会话保持、状态监控、智能网络地址转换（NAT）、通用持续性响应（GSR）、错误处理、TCP 优化等。有些负载均衡器还集成了防火墙、包过滤和攻击防护等功能。</p><p>负载均衡器可以部署在服务器与互联网链接之间，也可以作为两块网络适配器实现。在庞大的网络结构中，集群服务器的使用可能带来流量和负载问题，因此负载均衡技术应运而生。负载均衡器在网络管理中发挥着重要作用，通过它能够关注网络中的哪些方面需要进行优化和改进。</p><p>负载均衡器将传入的请求分发到应用服务器和数据库等计算资源。无论哪种情况，负载均衡器将从计算资源来的响应返回给恰当的客户端。负载均衡器的效用在于:</p><ul><li>防止请求进入不好的服务器</li><li>防止资源过载</li><li>帮助消除单一的故障点</li></ul><p>负载均衡器可以通过硬件（昂贵）或 HAProxy 等软件来实现。 增加的好处包括:</p><ul><li>SSL 终结 <ul><li>不需要再每台服务器上安装 <a href="https://en.wikipedia.org/wiki/X.509" title="X.509 证书">X.509 证书</a></li></ul></li><li>Session 留存 </li></ul><p>通常会设置采用<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%B7%A5%E4%BD%9C%E5%88%B0%E5%A4%87%E7%94%A8%E5%88%87%E6%8D%A2active-passive" title="工作─备用">工作─备用</a> 或 <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%8F%8C%E5%B7%A5%E4%BD%9C%E5%88%87%E6%8D%A2active-active" title="双工作">双工作</a> 模式的多个负载均衡器，以免发生故障。</p><p>负载均衡器能基于多种方式来路由流量:</p><ul><li>随机</li><li>最少负载</li><li>Session/cookie</li><li>轮询调度或加权轮询调度算法</li><li>四层负载均衡</li><li>七层负载均衡</li></ul><h3 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h3><p>四层负载均衡根据监看<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E9%80%9A%E8%AE%AF" title="传输层">传输层</a>的信息来决定如何分发请求。通常，这会涉及来源，目标 IP 地址和请求头中的端口，但不包括数据包（报文）内容。四层负载均衡执行<a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" title="网络地址转换（NAT）">网络地址转换（NAT）</a>来向上游服务器转发网络数据包。</p><h3 id="七层负载均衡器"><a href="#七层负载均衡器" class="headerlink" title="七层负载均衡器"></a>七层负载均衡器</h3><p>七层负载均衡器根据监控<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E9%80%9A%E8%AE%AF" title="应用层">应用层</a>来决定怎样分发请求。这会涉及请求头的内容，消息和 cookie。七层负载均衡器终结网络流量，读取消息，做出负载均衡判定，然后传送给特定服务器。比如，一个七层负载均衡器能直接将视频流量连接到托管视频的服务器，同时将更敏感的用户账单流量引导到安全性更强的服务器。</p><p>以损失灵活性为代价，四层负载均衡比七层负载均衡花费更少时间和计算资源，虽然这对现代商用硬件的性能影响甚微。</p><h2 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h2><p>负载均衡器还能帮助水平扩展，提高性能和可用性。使用商业硬件的性价比更高，并且比在单台硬件上垂直扩展更贵的硬件具有更高的可用性。相比招聘特定企业系统人才，招聘商业硬件方面的人才更加容易。</p><h3 id="水平扩展的缺点"><a href="#水平扩展的缺点" class="headerlink" title="水平扩展的缺点"></a>水平扩展的缺点</h3><ul><li>水平扩展引入了复杂度并涉及服务器复制<ul><li>服务器应该是无状态的:它们也不该包含像 session 或资料图片等与用户关联的数据。</li><li>session 可以集中存储在数据库或持久化<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E7%BC%93%E5%AD%98" title="缓存">缓存</a></li></ul></li><li>缓存和数据库等下游服务器需要随着上游服务器进行扩展，以处理更多的并发连接。</li></ul><h2 id="负载均衡器的缺点"><a href="#负载均衡器的缺点" class="headerlink" title="负载均衡器的缺点"></a>负载均衡器的缺点</h2><ul><li>如果没有足够的资源配置或配置错误，负载均衡器会变成一个性能瓶颈。</li><li>引入负载均衡器以帮助消除单点故障但导致了额外的复杂性。</li><li>单个负载均衡器会导致单点故障，但配置多个负载均衡器会进一步增加复杂性。</li></ul><h1 id="反向代理（web-服务器）"><a href="#反向代理（web-服务器）" class="headerlink" title="反向代理（web 服务器）"></a>反向代理（web 服务器）</h1><p><img src="https://img-blog.csdnimg.cn/2ba28846570b484f824cd42d4a0376e6.png" alt=""></p><p>资料来源：维基百科</p><h2 id="什么是反向代理"><a href="#什么是反向代理" class="headerlink" title="什么是反向代理"></a>什么是反向代理</h2><p>反向代理是一种可以集中地调用内部服务，并提供统一接口给公共客户的 web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端。</p><h2 id="反向代理的好处"><a href="#反向代理的好处" class="headerlink" title="反向代理的好处"></a>反向代理的好处</h2><ul><li>增加安全性 </li><li>提高可扩展性和灵活性 </li><li>本地终结 SSL 会话 <ul><li>免除了在每个服务器上安装 <a href="https://en.wikipedia.org/wiki/X.509" title="X.509">X.509</a> </li></ul></li><li>压缩 </li><li>缓存 </li><li>静态内容 <ul><li>HTML/CSS/JS</li></ul></li><li>图片</li><li>视频</li><li>等等</li></ul><h2 id="负载均衡器与反向代理"><a href="#负载均衡器与反向代理" class="headerlink" title="负载均衡器与反向代理"></a>负载均衡器与反向代理</h2><ul><li>当你有多个服务器时，部署负载均衡器非常有用。通常，负载均衡器将流量路由给一组功能相同的服务器上。</li><li>即使只有一台 web 服务器或者应用服务器时，反向代理也有用，可以参考上一节介绍的好处。</li><li>NGINX 和 HAProxy 等解决方案可以同时支持第七层反向代理和负载均衡。</li></ul><h2 id="反向代理的缺点"><a href="#反向代理的缺点" class="headerlink" title="反向代理的缺点"></a>反向代理的缺点</h2><ul><li>引入反向代理会增加系统的复杂度。</li><li>单独一个反向代理服务器仍可能发生单点故障，配置多台反向代理服务器（如<a href="https://en.wikipedia.org/wiki/Failover" title="故障转移">故障转移</a>）会进一步增加复杂度。<br>微服务的缺点：</li></ul><p>复杂性：微服务架构通常比单体架构更加复杂。开发者需要掌握多种技术栈，理解不同服务之间的协作方式，并处理服务之间的通信和数据一致性等问题。</p><p>部署和运维成本：由于微服务需要运行在多个进程中，因此它们的部署和运维成本可能会更高。此外，分布式系统的监控、日志管理和故障排查也具有一定的挑战性。</p><p>通信开销：微服务之间的通信通常基于 HTTP API，这可能会导致一定的网络开销和延迟。在高并发场景下，通信开销可能成为性能瓶颈。</p><p>数据一致性：在微服务架构中，不同服务之间的数据一致性需要特别关注。由于服务之间的数据交互是通过 API 进行的，可能会存在数据同步和事务处理的问题。</p><p>安全性：微服务架构中的多个服务可能使得系统更容易受到攻击。开发者需要充分考虑服务的安全防护，以及在分布式环境中应对安全问题的方法。</p><p>适用于小型项目：微服务架构在某些小型项目中可能过于复杂，浪费资源和时间。因此，开发者需要根据项目的实际需求和规模来选择合适的架构。</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>像 <a href="https://www.consul.io/docs/index.html" title="Consul">Consul</a>，<a href="https://coreos.com/etcd/docs/latest" title="Etcd">Etcd</a> 和 <a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper" title="Zookeeper">Zookeeper</a> 这样的系统可以通过追踪注册名、地址、端口等信息来帮助服务互相发现对方。<a href="https://www.consul.io/intro/getting-started/checks.html" title="Health checks">Health checks</a> 可以帮助确认服务的完整性和是否经常使用一个 <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEhttp" title="HTTP">HTTP</a> 路径。Consul 和 Etcd 都有一个内建的 <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E9%94%AE-%E5%80%BC%E5%AD%98%E5%82%A8" title="key-value 存储">key-value 存储</a> 用来存储配置信息和其他的共享信息。</p><h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><p>服务发现的主要流程如下：</p><ol><li>服务注册：当一个微服务启动时，它会将自己的地址、协议和相关的元数据注册到服务注册中心。服务注册中心负责维护一份可用的服务清单，以便其他服务可以查找到它。</li><li>服务发现：当一个微服务需要调用另一个微服务时，它会从服务注册中心获取可用的服务清单。根据清单中的信息，调用方服务可以找到被调用方的服务地址和端口，从而进行远程调用。</li><li>服务健康检查：服务发现过程中，还需要对服务进行健康检查，以确保调用的服务是正常运行的。服务注册中心可以定期接收服务提供的健康信息，从而实现对服务状态的监控。</li><li>服务注销：当一个微服务停止运行时，它会将自己的信息从服务注册中心注销。这样，其他服务在调用该服务时，会发现该服务已不存在，从而避免调用失败的情况。</li></ol><p>服务发现在微服务架构中起到了关键作用，它解决了服务之间的定位和通信问题。通过服务发现，微服务可以更加灵活、高效地进行通信和协作，从而提高整个系统的性能和可扩展性。</p><h2 id="应用使用微服务"><a href="#应用使用微服务" class="headerlink" title="应用使用微服务"></a>应用使用微服务</h2><p>应用层调用具体微服务时，需要经历以下几个步骤：</p><ol><li>服务注册：当一个微服务启动时，它会将自己的地址、协议和相关的元数据注册到服务注册中心。服务注册中心负责维护一份可用的服务清单，以便其他服务可以查找到它。</li><li>服务发现：当应用需要调用一个微服务时，它会从服务注册中心获取可用的服务清单。根据清单中的信息，应用可以找到需要调用的服务的地址和端口，从而进行远程调用。</li><li>服务调用：应用通过 HTTP 或其他协议向微服务发送请求，并将请求的数据传递给微服务。微服务接收到请求后，处理数据并生成响应，然后将响应返回给应用。</li><li>响应处理：应用接收到微服务返回的响应，并对响应数据进行处理。如果响应中包含错误信息，应用可以根据错误信息进行相应的处理，例如进行重试或者报错。</li><li>异常处理：在服务调用过程中，如果出现网络异常、超时或者其他异常情况，应用需要进行相应的异常处理，以确保系统的稳定性和可靠性。</li><li>负载均衡与熔断：为了提高系统的可用性和性能，可以采用负载均衡技术对微服务进行分发。此外，当微服务出现故障时，可以采用熔断机制将其从服务注册中心移除，以避免其他应用调用失败的情况。</li></ol><p>通过以上流程，应用可以实现对微服务的调用，从而充分利用微服务架构的优势，提高系统的灵活性、可扩展性和高可用性。同时，在调用过程中，还需要关注服务安全、数据一致性等问题，以确保微服务架构的稳定和可靠。</p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 系统设计 </category>
          
          <category> 负载均衡 </category>
          
          <category> 反向代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
            <tag> 负载均衡 </tag>
            
            <tag> 反向代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>microService</title>
      <link href="/2023/09/09/microService/"/>
      <url>/2023/09/09/microService/</url>
      
        <content type="html"><![CDATA[<h1 id="系统设计系列初衷"><a href="#系统设计系列初衷" class="headerlink" title="系统设计系列初衷"></a>系统设计系列初衷</h1><p>System Design Primer： 英文文档 <a href="https://so.csdn.net/so/search?q=GitHub&amp;spm=1001.2101.3001.7020">GitHub</a> - donnemartin/system-design-primer: Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.</p><p><a href="https://so.csdn.net/so/search?q=%E4%B8%AD%E6%96%87%E7%89%88&amp;spm=1001.2101.3001.7020">中文版</a>： <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md">https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md</a></p><p>初衷主要还是为了学习系统设计，但是这个中文版看起来就像<a href="https://so.csdn.net/so/search?q=%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91&amp;spm=1001.2101.3001.7020">机器翻译</a>的一样，所以还是手动做一些简单的笔记，并且在难以理解的地方对照英文版，根据自己的理解在AI的帮助下进行翻译和知识扩展。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p><img src="https://img-blog.csdnimg.cn/8ae191445c534fef94aaaa2726518c2e.png" alt=""></p><p>资料来源：可缩放系统构架介绍</p><p>首先需要了解下服务层和应用层的概念：</p><h2 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h2><p>主要负责处理系统的业务逻辑。服务层为应用层提供功能性的支持，包括数据验证、数据处理、业务流程控制等。服务层通过将底层数据处理和逻辑封装起来，为应用层提供了更高层次的抽象，使应用层可以更方便地使用这些服务。</p><h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><p>是软件系统的最高层次，直接为用户提供功能和服务。应用层包括各种应用程序、客户端和服务器等。应用层通过调用服务层提供的功能，实现了对用户需求的响应和满足。应用层需要关注用户交互、用户体验以及各种应用程序的实现。</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>服务层和应用层的关系主要体现在以下几个方面：</p><p>服务层为应用层提供服务：服务层通过封装底层数据处理和逻辑，为应用层提供了更高层次的抽象。应用层通过调用服务层提供的功能，实现了对用户需求的响应和满足。</p><p>应用层依赖服务层：应用层需要实现各种功能和服务，而这些功能和服务很大程度上依赖于服务层提供的支持。服务层设计的好坏直接影响应用层的性能、稳定性和可维护性。</p><p>服务层和应用层相互隔离：服务层和应用层在功能上相互独立，它们之间的接口清晰明确。这样，当需求发生变化时，可以灵活地进行调整和修改。服务层和应用层相互隔离的设计有助于提高系统的可维护性和可扩展性。</p><p>早期的服务层基于应用层存在，共同部署在同一个平台，共同运维。</p><p>而微服务的提出将 Web 服务层与应用层（也被称作平台层）分离，可以独立缩放和配置这两层。添加新的 API 只需要添加应用服务器，而不必添加额外的 web 服务器。</p><p>单一职责原则提倡小型的，自治的服务共同合作。小团队通过提供小型的服务，可以更激进地计划增长。</p><p>应用层中的工作进程也有可以实现<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%BC%82%E6%AD%A5" title="异步化">异步化</a>。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p><a href="https://en.wikipedia.org/wiki/Microservices" title="微服务">微服务</a>，可以被描述为一系列可以独立部署的小型的，模块化服务。每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标。</p><p>例如，Pinterest 可能有这些微服务： 用户资料、关注者、Feed 流、搜索、照片上传等。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>微服务的主要优势包括：</p><p>灵活性：微服务可以独立进行开发、测试和部署，从而加快软件开发的迭代速度。同时，每个服务都可以根据实际需求选择合适的技术栈，使得开发者能够更加灵活地应对不同的业务场景。</p><p>可扩展性：通过将复杂的应用程序拆分成多个简单的微服务，系统可以在需要时更容易地进行水平扩展。这使得系统能够根据业务需求的变化快速调整资源，提高系统的整体性能。</p><p>高可用性：由于每个微服务都是独立的，因此一个服务的故障不会直接导致整个系统崩溃。此外，微服务架构通常采用去中心化的设计，进一步提高了系统的容错能力。</p><p>松耦合：微服务之间的通信采用轻量级的 HTTP API，使得服务之间的依赖关系更加松散。这有助于降低系统间的耦合度，使得系统在面对需求变更时更加灵活。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>微服务的缺点：</p><p>复杂性：微服务架构通常比单体架构更加复杂。开发者需要掌握多种技术栈，理解不同服务之间的协作方式，并处理服务之间的通信和数据一致性等问题。</p><p>部署和运维成本：由于微服务需要运行在多个进程中，因此它们的部署和运维成本可能会更高。此外，分布式系统的监控、日志管理和故障排查也具有一定的挑战性。</p><p>通信开销：微服务之间的通信通常基于 HTTP API，这可能会导致一定的网络开销和延迟。在高并发场景下，通信开销可能成为性能瓶颈。</p><p>数据一致性：在微服务架构中，不同服务之间的数据一致性需要特别关注。由于服务之间的数据交互是通过 API 进行的，可能会存在数据同步和事务处理的问题。</p><p>安全性：微服务架构中的多个服务可能使得系统更容易受到攻击。开发者需要充分考虑服务的安全防护，以及在分布式环境中应对安全问题的方法。</p><p>适用于小型项目：微服务架构在某些小型项目中可能过于复杂，浪费资源和时间。因此，开发者需要根据项目的实际需求和规模来选择合适的架构。</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>像 <a href="https://www.consul.io/docs/index.html" title="Consul">Consul</a>，<a href="https://coreos.com/etcd/docs/latest" title="Etcd">Etcd</a> 和 <a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper" title="Zookeeper">Zookeeper</a> 这样的系统可以通过追踪注册名、地址、端口等信息来帮助服务互相发现对方。<a href="https://www.consul.io/intro/getting-started/checks.html" title="Health checks">Health checks</a> 可以帮助确认服务的完整性和是否经常使用一个 <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEhttp" title="HTTP">HTTP</a> 路径。Consul 和 Etcd 都有一个内建的 <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E9%94%AE-%E5%80%BC%E5%AD%98%E5%82%A8" title="key-value 存储">key-value 存储</a> 用来存储配置信息和其他的共享信息。</p><h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><p>服务发现的主要流程如下：</p><ol><li>服务注册：当一个微服务启动时，它会将自己的地址、协议和相关的元数据注册到服务注册中心。服务注册中心负责维护一份可用的服务清单，以便其他服务可以查找到它。</li><li>服务发现：当一个微服务需要调用另一个微服务时，它会从服务注册中心获取可用的服务清单。根据清单中的信息，调用方服务可以找到被调用方的服务地址和端口，从而进行远程调用。</li><li>服务健康检查：服务发现过程中，还需要对服务进行健康检查，以确保调用的服务是正常运行的。服务注册中心可以定期接收服务提供的健康信息，从而实现对服务状态的监控。</li><li>服务注销：当一个微服务停止运行时，它会将自己的信息从服务注册中心注销。这样，其他服务在调用该服务时，会发现该服务已不存在，从而避免调用失败的情况。</li></ol><p>服务发现在微服务架构中起到了关键作用，它解决了服务之间的定位和通信问题。通过服务发现，微服务可以更加灵活、高效地进行通信和协作，从而提高整个系统的性能和可扩展性。</p><h2 id="应用使用微服务"><a href="#应用使用微服务" class="headerlink" title="应用使用微服务"></a>应用使用微服务</h2><p>应用层调用具体微服务时，需要经历以下几个步骤：</p><ol><li>服务注册：当一个微服务启动时，它会将自己的地址、协议和相关的元数据注册到服务注册中心。服务注册中心负责维护一份可用的服务清单，以便其他服务可以查找到它。</li><li>服务发现：当应用需要调用一个微服务时，它会从服务注册中心获取可用的服务清单。根据清单中的信息，应用可以找到需要调用的服务的地址和端口，从而进行远程调用。</li><li>服务调用：应用通过 HTTP 或其他协议向微服务发送请求，并将请求的数据传递给微服务。微服务接收到请求后，处理数据并生成响应，然后将响应返回给应用。</li><li>响应处理：应用接收到微服务返回的响应，并对响应数据进行处理。如果响应中包含错误信息，应用可以根据错误信息进行相应的处理，例如进行重试或者报错。</li><li>异常处理：在服务调用过程中，如果出现网络异常、超时或者其他异常情况，应用需要进行相应的异常处理，以确保系统的稳定性和可靠性。</li><li>负载均衡与熔断：为了提高系统的可用性和性能，可以采用负载均衡技术对微服务进行分发。此外，当微服务出现故障时，可以采用熔断机制将其从服务注册中心移除，以避免其他应用调用失败的情况。</li></ol><p>通过以上流程，应用可以实现对微服务的调用，从而充分利用微服务架构的优势，提高系统的灵活性、可扩展性和高可用性。同时，在调用过程中，还需要关注服务安全、数据一致性等问题，以确保微服务架构的稳定和可靠。</p>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 系统设计 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2023/09/09/database/"/>
      <url>/2023/09/09/database/</url>
      
        <content type="html"><![CDATA[<h1 id="系统设计系列初衷"><a href="#系统设计系列初衷" class="headerlink" title="系统设计系列初衷"></a>系统设计系列初衷</h1><p>System Design Primer： 英文文档 GitHub - donnemartin/system-design-primer: Learn how to design large-scale systems. Prep for the system design interview. Includes Anki flashcards.</p><p>中文版： <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md">https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md</a></p><p>初衷主要还是为了学习系统设计，但是这个中文版看起来就像机器翻译的一样，所以还是手动做一些简单的笔记，并且在难以理解的地方对照英文版，根据自己的理解在AI的帮助下进行翻译和知识扩展。</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><img src="https://img-blog.csdnimg.cn/3ae639fb3d4a410bbd450795c263e4da.png" alt=""></p><p>资料来源：扩展你的用户数到第一个一千万</p><h1 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h1><p>数据库（DataBase，DB）是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。它是一个按数据结构来存储和管理数据的计算机软件系统。数据库的概念包含了数据、数据组织、数据存储、数据管理四个方面。数据库具有以下几个特点：</p><ol><li>数据持久化：数据库中的数据可以长期保存，并且可以在需要时进行查询和修改。</li><li>数据共享：多个用户和应用程序可以同时访问数据库中的数据，实现数据共享。</li><li>数据一致性：数据库中的数据保持一致状态，当多个用户同时对数据进行操作时，数据库会确保数据的一致性。</li><li>数据可扩展性：数据库可以很容易地扩展，增加新的数据和功能。</li><li>高性能：通过使用索引、缓存等技术，数据库可以提高数据检索和操作的速度。</li></ol><h1 id="数据库的类型"><a href="#数据库的类型" class="headerlink" title="数据库的类型"></a>数据库的类型</h1><p>数据库主要有以下几种类型：</p><ol><li>关系型数据库（RDBMS）：这种类型的数据库以表格的形式存储数据，表格由行（记录）和列（字段）组成。常见的关系型数据库有 MySQL、Oracle、SQL Server、PostgreSQL 等。关系型数据库的特点是数据结构清晰、易于理解，支持复杂的查询和事务处理，但可能不太适合处理大量的非结构化数据。</li><li>非关系型数据库（NoSQL）：这类数据库主要包括 Key-Value 型（如 Redis、Riak）、列族型（如 Cassandra、HBase）、文档型（如 MongoDB、CouchDB）和图型（如 Neo4j、OrientDB）等。非关系型数据库适合存储结构不规则、半结构化或非结构化的数据，具有较高的横向扩展能力和高性能，但数据一致性可能较低。</li><li>层次型数据库：这种数据库以树形结构组织数据，其中数据被分为层次结构，每个节点表示一个记录。常见的层次型数据库有 IBM IMS、SAP HANA 等。</li><li>网络型数据库：这种数据库以图形或网络结构组织数据，数据之间的关系通过节点和边表示。常见的网络型数据库有 Neo4j、OrientDB 等。</li><li>时序型数据库：这种数据库主要用于存储时间序列数据，如股票行情、气象数据等。常见的时序型数据库有 InfluxDB、OpenTSDB 等。</li></ol><p>每种数据库类型都有其适用的场景，需要根据具体需求选择合适的数据库。</p><h2 id="关系型数据库管理系统（RDBMS）"><a href="#关系型数据库管理系统（RDBMS）" class="headerlink" title="关系型数据库管理系统（RDBMS）"></a>关系型数据库管理系统（RDBMS）</h2><p>像 MYSQL 这样的关系型数据库是一系列以表的形式组织的数据项集合。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务（transaction）是数据库管理系统（DBMS）中的一个重要概念，它表示为一组逻辑上相关的操作序列。这些操作要么全部完成，要么全部不做，是一个不可分割的工作单位。事务用于保证数据的完整性和一致性，在数据库中执行时，可以是对数据进行增加、修改、删除等操作。</p><p>ACID 用来描述关系型数据库<a href="https://en.wikipedia.org/wiki/Database_transaction" title="事务">事务</a>的特性。</p><ul><li>原子性  - 每个事务内部所有操作要么全部完成，要么全部不完成。</li><li>一致性  - 任何事务都使数据库从一个有效的状态转换到另一个有效状态。</li><li>隔离性  - 并发执行事务的结果与顺序执行事务的结果相同。</li><li>持久性  - 事务提交后，对系统的影响是永久的。</li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>关系型数据库扩展包括许多技术：主从复制、主主复制、联合、分片、非规范化和 SQL调优。</p><p><img src="https://img-blog.csdnimg.cn/ebdfaa7933eb4f30868182cdfaae8321.png" alt=""></p><p>资料来源：可扩展性、可用性、稳定性、模式</p><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>我们将数据库分为主库和从库，主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现。</p><p>主从复制的缺点：</p><ul><li>将从库提升为主库需要执行额外的逻辑。</li><li>主从数据库的数据一致性问题，存在数据延迟和宕机数据不同步</li></ul><p><img src="https://img-blog.csdnimg.cn/62027583a7764638bea5c55d0fd75b54.png" alt=""></p><p>资料来源：可扩展性、可用性、稳定性、模式</p><h4 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h4><p>两个主库都负责读操作和写操作，写入操作时互相协调。如果其中一个主库挂机，系统可以继续读取和写入。</p><p>主主复制的缺点</p><ul><li>需要添加负载均衡器或者在应用逻辑中做改动，来确定写入哪一个数据库。</li><li>多数主-主系统要么不能保证一致性（违反 ACID），要么因为同步产生了写入延迟。</li><li>随着更多写入节点的加入和延迟的提高，如何解决冲突显得越发重要。</li><li>主主服务器之间的数据一致性同步问题。</li></ul><p>数据一致性同步问题可能存在的情况</p><ul><li>如果主库在将新写入的数据复制到其他节点前挂掉，则有数据丢失的可能。</li><li>写入会被重放到负责读取操作的副本。副本可能因为过多写操作阻塞住，导致读取功能异常。</li><li>读取从库越多，需要复制的写入数据就越多，导致更严重的复制延迟。</li><li>在某些数据库系统中，写入主库的操作可以用多个线程并行写入，但读取副本只支持单线程顺序地写入。</li><li>复制意味着更多的硬件和额外的复杂度。</li></ul><h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><p><img src="https://img-blog.csdnimg.cn/4b3a93df89cd48e6961a6285304c9392.png" alt=""></p><p>资料来源：扩展你的用户数到第一个一千万</p><p>联合（或按功能划分）将数据库按对应功能分割。例如，可以有三个数据库：论坛、用户和产品，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着更高的缓存命中几率。没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p><p>联合的缺点</p><ul><li>如果数据库模式需要大量的功能和数据表，联合的效率并不好。</li><li>需要更新应用程序的逻辑来确定要读取和写入哪个数据库。</li><li>用 <a href="http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers" title="server link">server link</a> 从两个库联结数据更复杂。</li><li>联合需要更多的硬件和额外的复杂度。</li></ul><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p><img src="https://img-blog.csdnimg.cn/2953da7d41c8478380050d1f3d30aca3.png" alt=""></p><p>资料来源：可扩展性、可用性、稳定性、模式</p><p>分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。</p><p>类似<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E8%81%94%E5%90%88" title="联合">联合</a>的优点，分片可以减少读取和写入流量，减少复制并提高缓存命中率。也减少了索引，通常意味着查询更快，性能更好。如果一个分片出问题，其他的仍能运行，可以使用某种形式的冗余来防止数据丢失。类似联合，没有只能串行写入的中心化主库，可以并行写入，提高负载能力。</p><p>常见的做法是用户姓氏的首字母或者用户的地理位置来分隔用户表。</p><p>分片的缺点</p><ul><li>需要修改应用程序的逻辑来实现分片，这会带来复杂的 SQL 查询。</li><li>分片不合理可能导致数据负载不均衡。例如，被频繁访问的用户数据会导致其所在分片的负载相对其他分片高。<ul><li>再平衡会引入额外的复杂度。基于<a href="http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html" title="一致性哈希">一致性哈希</a>的分片算法可以减少这种情况。</li></ul></li><li>联结多个分片的数据操作更复杂。</li><li>分片需要更多的硬件和额外的复杂度。</li></ul><h3 id="非规范化"><a href="#非规范化" class="headerlink" title="非规范化"></a>非规范化</h3><p>非规范化试图以写入性能为代价来换取读取性能。在多个表中冗余数据副本，以避免高成本的联结操作。一些关系型数据库，比如 <a href="https://en.wikipedia.org/wiki/PostgreSQL" title="PostgreSQL">PostgreSQL</a> 和 Oracle 支持<a href="https://en.wikipedia.org/wiki/Materialized_view" title="物化视图">物化视图</a>，可以处理冗余信息存储和保证冗余副本一致。</p><p>当数据使用诸如<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E8%81%94%E5%90%88" title="联合">联合</a>和<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E5%88%86%E7%89%87" title="分片">分片</a>等技术被分割，进一步提高了处理跨数据中心的联结操作复杂度。非规范化可以规避这种复杂的联结操作。</p><p>在多数系统中，读取操作的频率远高于写入操作，比例可达到 100:1，甚至 1000:1。需要复杂的数据库联结的读取操作成本非常高，在磁盘操作上消耗了大量时间。</p><p>非规范化的缺点：</p><ul><li>数据会冗余。</li><li>约束可以帮助冗余的信息副本保持同步，但这样会增加数据库设计的复杂度。</li><li>非规范化的数据库在高写入负载下性能可能比规范化的数据库差。</li></ul><h4 id="SQL-调优"><a href="#SQL-调优" class="headerlink" title="SQL 调优"></a>SQL 调优</h4><p>SQL 调优是一个范围很广的话题，有很多相关的<a href="https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&amp;field-keywords=sql+tuning" title="书">书</a>可以作为参考。</p><p>利用<strong>基准测试</strong>和<strong>性能分析</strong>来模拟和发现系统瓶颈很重要。</p><ul><li><strong>基准测试</strong> - 用 <a href="http://httpd.apache.org/docs/2.2/programs/ab.html" title="ab">ab</a> 等工具模拟高负载情况。</li><li><strong>性能分析</strong> - 通过启用如<a href="http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html" title="慢查询日志">慢查询日志</a>等工具来辅助追踪性能问题。</li></ul><p>基准测试和性能分析可能会指引你到以下优化方案。</p><h5 id="改进Schema"><a href="#改进Schema" class="headerlink" title="改进Schema"></a>改进Schema</h5><ul><li>为了实现快速访问，MySQL 在磁盘上用连续的块存储数据。</li><li>使用 <code>CHAR</code> 类型存储固定长度的字段，不要用 <code>VARCHAR</code>。<ul><li><code>CHAR</code> 在快速、随机访问时效率很高。如果使用 <code>VARCHAR</code>，如果你想读取下一个字符串，不得不先读取到当前字符串的末尾。</li></ul></li><li>使用 <code>TEXT</code> 类型存储大块的文本，例如博客正文。<code>TEXT</code> 还允许布尔搜索。使用 <code>TEXT</code> 字段需要在磁盘上存储一个用于定位文本块的指针。</li><li>使用 <code>INT</code> 类型存储高达 2^32 或 40 亿的较大数字。</li><li>使用 <code>DECIMAL</code> 类型存储货币可以避免浮点数表示错误。</li><li>避免使用 <code>BLOBS</code> 存储实际对象，而是用来存储存放对象的位置。</li><li><code>VARCHAR(255)</code> 是以 8 位数字存储的最大字符数，在某些关系型数据库中，最大限度地利用字节。</li><li>在适用场景中设置 <code>NOT NULL</code> 约束来<a href="http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search" title="提高搜索性能">提高搜索性能</a>。</li></ul><h5 id="使用正确的index"><a href="#使用正确的index" class="headerlink" title="使用正确的index"></a>使用正确的index</h5><ul><li>你正查询（<code>SELECT</code>、<code>GROUP BY</code>、<code>ORDER BY</code>、<code>JOIN</code>）的列如果用了索引会更快。</li><li>索引通常表示为自平衡的 <a href="https://en.wikipedia.org/wiki/B-tree" title="B 树">B 树</a>，可以保持数据有序，并允许在对数时间内进行搜索，顺序访问，插入，删除操作。</li><li>设置索引，会将数据存在内存中，占用了更多内存空间。</li><li>写入操作会变慢，因为索引需要被更新。</li><li>加载大量数据时，禁用索引再加载数据，然后重建索引，这样也许会更快。</li></ul><h5 id="避免高成本的join操作"><a href="#避免高成本的join操作" class="headerlink" title="避免高成本的join操作"></a>避免高成本的join操作</h5><ul><li>有性能需要，可以进行非规范化。</li></ul><h5 id="分割数据表"><a href="#分割数据表" class="headerlink" title="分割数据表"></a>分割数据表</h5><ul><li>将热点数据拆分到单独的数据表中，可以有助于缓存。</li></ul><h5 id="调优查询缓存"><a href="#调优查询缓存" class="headerlink" title="调优查询缓存"></a>调优查询缓存</h5><ul><li>在某些情况下，<a href="http://dev.mysql.com/doc/refman/5.7/en/query-cache" title="查询缓存">查询缓存</a>可能会导致<a href="https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/" title="性能问题">性能问题</a>。</li></ul><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>NoSQL 是<strong>键-值数据库</strong>、<strong>文档型数据库</strong>、<strong>列型数据库</strong>或<strong>图数据库</strong>的统称。数据库是非规范化的，表联结大多在应用程序代码中完成。大多数 NoSQL 无法实现真正符合 ACID 的事务，支持<a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7" title="最终一致">最终一致</a>。</p><p><strong>BASE</strong> 通常被用于描述 NoSQL 数据库的特性。相比 <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#cap-%E7%90%86%E8%AE%BA" title="CAP 理论">CAP 理论</a>，BASE 强调可用性超过一致性。</p><ul><li><strong>基本可用</strong> - 系统保证可用性。</li><li><strong>软状态</strong> - 即使没有输入，系统状态也可能随着时间变化。</li><li><strong>最终一致性</strong> - 经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入。</li></ul><p>举例说明BASE特性：</p><ol><li>基本可用（Basic Availability）：基本可用是指系统在面临网络分区、节点故障等异常情况时，仍然能够继续提供服务。例如，在这个电商系统中，当某个节点或网络出现故障时，系统可以将用户请求转发到其他正常的节点上，确保系统仍然可以正常运行。</li><li>软状态（Soft State）：软状态是指系统在面临部分失败时，可以接受数据的不一致性。在 NOSQL 数据库中，通常不保证强一致性。以购物车信息为例，当系统在更新购物车信息时遇到网络分区或其他故障，可能导致部分节点上的购物车信息与另一部分节点上的信息不一致。但是，这种不一致性在一定时间内可以通过系统内部的机制进行修复。例如，通过异步复制、数据补偿等手段，使不同节点上的购物车信息最终达到一致状态。</li><li>最终一致性（Eventual Consistency）：最终一致性是指系统在面临故障恢复后，可以保证数据的一致性。在 NOSQL 数据库中，通常采用乐观锁、版本号等机制来确保最终一致性。以购物车信息为例，当系统检测到购物车信息在不同节点上存在不一致时，可以通过乐观锁机制进行冲突检测，并选择一个优先级较高的版本作为最终结果。同时，系统还可以通过版本号来跟踪数据的变化，当发现数据不一致时，可以通过回滚机制将数据恢复到一致状态。</li></ol><p>除了在 <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#sql-%E8%BF%98%E6%98%AF-nosql" title="SQL 还是 NoSQL">SQL 还是 NoSQL</a> 之间做选择，了解哪种类型的 NoSQL 数据库最适合你的用例也是非常有帮助的。我们将在下一节中快速了解下 <strong>键-值存储</strong>、<strong>文档型存储</strong>、<strong>列型存储</strong>和<strong>图存储</strong>数据库。</p><h3 id="键-值存储"><a href="#键-值存储" class="headerlink" title="键-值存储"></a>键-值存储</h3><blockquote><p>抽象模型：哈希表</p></blockquote><p>键-值存储通常可以实现 O(1) 时间读写，用内存或 SSD 存储数据。数据存储可以按<a href="https://en.wikipedia.org/wiki/Lexicographical_order" title="字典顺序">字典顺序</a>维护键，从而实现键的高效检索。键-值存储可以用于存储元数据。</p><p>键-值存储性能很高，通常用于存储简单数据模型或频繁修改的数据，如存放在内存中的缓存。键-值存储提供的操作有限，如果需要更多操作，复杂度将转嫁到应用程序层面。</p><p>键-值存储是如文档存储，在某些情况下，甚至是图存储等更复杂的存储系统的基础。</p><h3 id="文档类型存储"><a href="#文档类型存储" class="headerlink" title="文档类型存储"></a>文档类型存储</h3><blockquote><p>抽象模型：将文档作为值的键-值存储</p></blockquote><p>文档类型存储以文档（XML、JSON、二进制文件等）为中心，文档存储了指定对象的全部信息。文档存储根据文档自身的内部结构提供 API 或查询语句来实现查询。请注意，许多键-值存储数据库有用值存储元数据的特性，这也模糊了这两种存储类型的界限。</p><p>基于底层实现，文档可以根据集合、标签、元数据或者文件夹组织。尽管不同文档可以被组织在一起或者分成一组，但相互之间可能具有完全不同的字段。</p><p>MongoDB 和 CouchDB 等一些文档类型存储还提供了类似 SQL 语言的查询语句来实现复杂查询。DynamoDB 同时支持键-值存储和文档类型存储。</p><p>文档类型存储具备高度的灵活性，常用于处理偶尔变化的数据。</p><h3 id="列型存储"><a href="#列型存储" class="headerlink" title="列型存储"></a>列型存储</h3><p><img src="https://img-blog.csdnimg.cn/9a8d55c262e547a49b0fabc6c71a7d7f.png" alt=""><br><strong><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html" title="资料来源: SQL 和 NoSQL，一个简短的历史">资料来源: SQL 和 NoSQL，一个简短的历史</a></strong></p><blockquote><p>抽象模型：嵌套的 <code>ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp&gt;&gt;</code> 映射</p></blockquote><p>类型存储的基本数据单元是列（名／值对）。列可以在列族（类似于 SQL 的数据表）中被分组。超级列族再分组普通列族。你可以使用行键独立访问每一列，具有相同行键值的列组成一行。每个值都包含版本的时间戳用于解决版本冲突。</p><p>Google 发布了第一个列型存储数据库 <a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf" title="Bigtable">Bigtable</a>，它影响了 Hadoop 生态系统中活跃的开源数据库 <a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture" title="HBase">HBase</a> 和 Facebook 的 <a href="http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html" title="Cassandra">Cassandra</a>。像 BigTable，HBase 和 Cassandra 这样的存储系统将键以字母顺序存储，可以高效地读取键列。</p><p>列型存储具备高可用性和高可扩展性。通常被用于大数据相关存储。</p><h3 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h3><p><img src="https://img-blog.csdnimg.cn/a6da9719d6ad4e4fa604e4f75b6ea7ca.png" alt=""></p><p><strong><a href="https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png" title="资料来源：图数据库">资料来源：图数据库</a></strong></p><blockquote><p>抽象模型： 图</p></blockquote><p>在图数据库中，一个节点对应一条记录，一个弧对应两个节点之间的关系。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。</p><p>图数据库为存储复杂关系的数据模型，如社交网络，提供了很高的性能。它们相对较新，尚未广泛应用，查找开发工具或者资源相对较难。许多图只能通过 <a href="https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md#%E8%A1%A8%E8%BF%B0%E6%80%A7%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BBrest" title="REST API">REST API</a> 访问。</p><h2 id="选择SQL还是NOSQL"><a href="#选择SQL还是NOSQL" class="headerlink" title="选择SQL还是NOSQL"></a>选择SQL还是NOSQL</h2><p><img src="https://img-blog.csdnimg.cn/565022df832749f0b42e77c545799b65.png" alt=""></p><p>选取 <strong>SQL</strong> 的原因:</p><ul><li>结构化数据</li><li>严格的模式</li><li>关系型数据</li><li>需要复杂的联结操作</li><li>事务</li><li>清晰的扩展模式</li><li>既有资源更丰富：开发者、社区、代码库、工具等</li><li>通过索引进行查询非常快</li></ul><p>选取 <strong>NoSQL</strong> 的原因：</p><ul><li>半结构化数据</li><li>动态或灵活的模式</li><li>非关系型数据</li><li>不需要复杂的联结操作</li><li>存储 TB （甚至 PB）级别的数据</li><li>高数据密集的工作负载</li><li>IOPS 高吞吐量</li></ul><p>适合 NoSQL 的示例数据：</p><ul><li>埋点数据和日志数据</li><li>排行榜或者得分数据</li><li>临时数据，如购物车</li><li>频繁访问的（“热”）表</li><li>元数据／查找表</li></ul><p>额外参考：</p><ul><li>数据结构和关系复杂度：如果数据具有复杂的结构和关系，例如涉及到多对多、一对多、一对多或多对多等关系，那么 SQL 数据库可能更适合您，因为 SQL 数据库在处理复杂关系和数据模式方面具有较强的能力。而 NOSQL 数据库通常适用于数据结构较为简单、关系不太复杂的场景。</li><li>数据读写性能要求：SQL 数据库在读取和写入数据时，通常需要遵循一定的事务处理和数据完整性规则，这可能会导致性能开销。如果您的系统对数据读写性能要求很高，可以考虑使用 NOSQL 数据库，因为它们通常具有更高的读写性能。但是，需要注意的是，NOSQL 数据库在数据一致性方面可能没有 SQL 数据库那么强。</li><li>数据规模：当数据规模较大时，NOSQL 数据库通常具有更好的横向扩展能力，可以应对海量数据的存储和查询。而 SQL 数据库在处理大规模数据时，可能需要更多的硬件资源和优化策略。因此，在数据规模较大的场景下，可以考虑使用 NOSQL 数据库。</li><li>数据一致性和事务处理：如果您的系统对数据一致性和事务处理有较高的要求，那么 SQL 数据库可能更适合您。因为 SQL 数据库遵循 ACID（原子性、一致性、隔离性、持久性）原则，能够确保数据的完整性和事务的完整执行。而 NOSQL 数据库通常遵循 BASE（基本可用、软状态、最终一致性）原则，对数据一致性的要求相对较低。</li><li>系统灵活性和可扩展性：NOSQL 数据库通常具有更高的灵活性和可扩展性，可以更好地适应不断变化的业务需求。而 SQL 数据库通常需要预先定义好数据结构和关系，可能在应对需求变化时较为困难。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 原创 </category>
          
          <category> 系统设计 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/08/hello-world/"/>
      <url>/2023/09/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
